# ========================================
# INPUT: Consume from Kafka
# ========================================
input {
  kafka {
    bootstrap_servers => "kafka:9092"
    topics => ["web-logs"]
    group_id => "logstash-consumer-group"
    codec => json
    auto_offset_reset => "latest"
    consumer_threads => 2
    decorate_events => true
  }
}

# ========================================
# FILTER: Transform and Enrich
# ========================================
filter {
  # Parse timestamp
  if [timestamp] {
    date {
      match => ["timestamp", "ISO8601"]
      target => "@timestamp"
    }
  }

  # User Agent Parsing
  if [user_agent] {
    useragent {
      source => "user_agent"
      target => "ua"
    }
    # Flatten ua fields to avoid nested object mapping issues
    if [ua][device][name] {
      mutate { add_field => { "ua_device" => "%{[ua][device][name]}" } }
    }
    if [ua][os][name] {
      mutate { add_field => { "ua_os" => "%{[ua][os][name]}" } }
    }
    if [ua][os][full] {
      mutate { add_field => { "ua_os_full" => "%{[ua][os][full]}" } }
    }
    if [ua][name] {
      mutate { add_field => { "ua_name" => "%{[ua][name]}" } }
    }
    if [ua][version] {
      mutate { add_field => { "ua_version" => "%{[ua][version]}" } }
    }
    mutate { remove_field => ["ua"] }
  }

  # GeoIP Enrichment (skip private IPs)
  if [client_ip] and [client_ip] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.0\.)/ {
    geoip {
      source => "client_ip"
      target => "geo"
      fields => ["city_name", "country_name", "location"]
    }
  }

  # Categorize HTTP status
  if [status_code] {
    if [status_code] >= 200 and [status_code] < 300 {
      mutate { add_field => { "status_category" => "success" } }
    } else if [status_code] >= 400 and [status_code] < 500 {
      mutate { add_field => { "status_category" => "client_error" } }
      mutate { add_tag => ["error"] }
    } else if [status_code] >= 500 {
      mutate { add_field => { "status_category" => "server_error" } }
      mutate { add_tag => ["error"] }
    }
  }

  # Response time category
  if [response_time_ms] {
    if [response_time_ms] < 100 {
      mutate { add_field => { "response_category" => "fast" } }
    } else if [response_time_ms] < 500 {
      mutate { add_field => { "response_category" => "normal" } }
    } else {
      mutate { add_field => { "response_category" => "slow" } }
      mutate { add_tag => ["slow_response"] }
    }
  }

  # Convert types
  mutate {
    convert => {
      "status_code" => "integer"
      "response_time_ms" => "float"
    }
  }

  # Remove unnecessary fields
  mutate {
    remove_field => ["@version"]
  }
}

# ========================================
# OUTPUT: Index to Elasticsearch
# ========================================
output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "web-logs-%{+YYYY.MM.dd}"
    manage_template => true
    template_name => "web-logs"
  }

  # Debug output (optional - comment in production)
  # stdout { codec => rubydebug }
}
